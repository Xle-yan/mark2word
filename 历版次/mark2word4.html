<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown ↔ Word 完美版</title>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <script src="https://unpkg.com/turndown-plugin-gfm/dist/turndown-plugin-gfm.js"></script>

    <!-- MathJax: 用于渲染 LaTeX 数学公式（$...$ / $$...$$） -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/docx@7.1.0/build/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <style>
        :root { --primary: #2563eb; --bg: #f3f4f6; --border: #d1d5db; --toolbar-h: 60px; }
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: "Microsoft YaHei", sans-serif; background: var(--bg);
            height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        header {
            height: var(--toolbar-h); background: white; border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); z-index: 10;
        }

        h1 { font-size: 18px; color: #374151; display: flex; align-items: center; gap: 10px; }
        .controls { display: flex; align-items: center; gap: 15px; }
        .filename-group { display: flex; align-items: center; gap: 8px; }
        .filename-group label { font-size: 14px; color: #6b7280; white-space: nowrap; }
        .filename-group input { 
            padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px;
            font-size: 14px; width: 200px; outline: none; transition: all 0.2s;
        }
        .filename-group input:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }
        .filename-group input::placeholder { color: #9ca3af; }
        .btn-group { display: flex; gap: 10px; }
        button {
            padding: 8px 16px; border: 1px solid var(--border); background: white;
            border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; 
            align-items: center; gap: 6px; color: #374151; transition: all 0.2s;
        }
        button:hover { background: #f9fafb; border-color: #9ca3af; }
        button.primary { background: var(--primary); color: white; border-color: var(--primary); }
        button.primary:hover { background: #1d4ed8; }

        .main { flex: 1; display: flex; height: calc(100vh - var(--toolbar-h)); }
        .pane { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .editor-container { flex: 1; background: #1e1e1e; position: relative; }
        textarea {
            width: 100%; height: 100%; background: #1e1e1e; color: #e5e7eb;
            border: none; resize: none; padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace; font-size: 14px; line-height: 1.6; outline: none;
        }
        .pane-label {
            background: #f3f4f6; padding: 8px 15px; font-size: 12px; color: #666;
            border-bottom: 1px solid var(--border); border-top: 1px solid var(--border);
        }
        .gutter {
            width: 60px; background: #e5e7eb; border-left: 1px solid var(--border); 
            border-right: 1px solid var(--border); display: flex; flex-direction: column; 
            justify-content: center; align-items: center; gap: 20px; z-index: 5;
        }
        .action-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 1px solid #ccc;
            background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 20px;
            color: var(--primary); transition: transform 0.2s;
        }
        .action-btn:hover { transform: scale(1.1); color: #1d4ed8; border-color: var(--primary); }
        
        .preview-container {
            flex: 1; background: #e0e0e0; overflow-y: auto; padding: 30px; display: block; 
        }

        #word-page {
            background: white; width: 21cm; min-height: 29.7cm; padding: 2.54cm;
            box-shadow: 0 0 10px rgba(0,0,0,0.1); outline: none; color: #000;
            text-align: justify;
            font-family: "Microsoft YaHei", sans-serif; font-size: 12pt; line-height: 1.5;
            margin: 0 auto 50px auto; height: auto; overflow: visible;
        }

        #word-page h1 { font-size: 22pt; margin: 24pt 0 12pt; font-weight: bold; color: #000; }
        #word-page h2 { font-size: 16pt; margin: 24pt 0 12pt; font-weight: bold; color: #000; }
        #word-page h3 { font-size: 14pt; margin: 12pt 0 6pt; font-weight: bold; color: #000; }
        #word-page h4 { font-size: 12pt; margin: 10pt 0 6pt; font-weight: bold; color: #000; font-style: normal; }
        #word-page h5 { font-size: 12pt; margin: 10pt 0 6pt; font-weight: bold; color: #000; font-style: normal; }
        #word-page h6 { font-size: 12pt; margin: 10pt 0 6pt; font-weight: bold; color: #000; font-style: normal; }
        
        #word-page p { margin: 0 0 10pt; text-indent: 2em; }
        
        #word-page ul, #word-page ol { margin: 0 0 10pt; padding-left: 2em; text-indent: 0; }
        #word-page li { margin-bottom: 0; list-style-position: outside; }
        #word-page li p { text-indent: 0; margin-bottom: 0; }
        #word-page ul ul, #word-page ol ul, #word-page ul ol, #word-page ol ol {
            margin-top: 0; margin-bottom: 0;
        }

        #word-page blockquote { border-left: 4px solid #ddd; padding-left: 12pt; color: #555; margin: 0 0 10pt 0; }
        #word-page blockquote p { text-indent: 0; }

        #word-page table { border-collapse: collapse; width: 100%; margin-bottom: 10pt; text-indent: 0; }
        #word-page th, #word-page td { border: 1px solid #000; padding: 8px; text-align: center; font-size: 10.5pt; }
        #word-page th { background-color: #f3f4f6; font-weight: bold; }

        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
            border-radius: 20px; font-size: 14px; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; z-index: 100;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

    <header>
        <h1><span>MD ↔ Word 最终版</span></h1>
        <div class="controls">
            <div class="filename-group">
                <label for="filename">文件名：</label>
                <input type="text" id="filename" placeholder="自动提取或输入..." title="留空则自动从第一个标题提取，或使用日期时间" />
            </div>
            <div class="btn-group">
                <button onclick="downloadMarkdown()">导出 Markdown</button>
                <button class="primary" onclick="downloadDocx()">导出 Word (.docx)</button>
            </div>
        </div>
    </header>

    <div class="main">
        <div class="pane" style="border-right: 1px solid #ccc;">
            <div class="pane-label">Markdown 源码</div>
            <div class="editor-container">
                <textarea id="md-input" placeholder="在此输入 Markdown..."># 嵌套列表测试

## 测试加粗和斜体

* 外层列表项 1
* 外层列表项 2
  * 嵌套列表项 A（包含**加粗文本**）
  * 嵌套列表项 B（包含*斜体文本*）
  * 嵌套列表项 C（包含**塔坛缘分墙**）
* 外层列表项 3

## 测试有序列表

1. 第一项
2. 第二项
   - 嵌套的无序列表 A
   - 嵌套的无序列表 B（**加粗内容**）
     1. 三级有序列表
     2. 继续测试
   - 嵌套的无序列表 C
     1. 新的三级有序列表（应该从1开始）
     2. 继续
3. 第三项</textarea>
            </div>
        </div>

        <div class="gutter">
            <div class="action-btn" onclick="convertMdToPreview()">➡</div>
            <div class="action-btn" onclick="convertPreviewToMd()">⬅</div>
        </div>

        <div class="pane">
            <div class="pane-label">Word 预览 / 粘贴区</div>
            <div class="preview-container">
                <div id="word-page" contenteditable="true"></div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast">操作成功</div>

    <script>
        const mdInput = document.getElementById('md-input');
        const wordPage = document.getElementById('word-page');
        const filenameInput = document.getElementById('filename');
        
        const turndownService = new TurndownService({ headingStyle: 'atx', bulletListMarker: '-' });
        const gfm = turndownPluginGfm.gfm;
        turndownService.use(gfm);

        // turndown：把预览区渲染后的公式节点还原为 $...$ / $$...$$
        turndownService.addRule('tex-inline', {
            filter: function (node) {
                return node.nodeType === 1 && node.classList && node.classList.contains('tex-inline') && node.getAttribute('data-tex');
            },
            replacement: function (_content, node) {
                const tex = node.getAttribute('data-tex') || '';
                return `$${tex}$`;
            }
        });
        turndownService.addRule('tex-block', {
            filter: function (node) {
                return node.nodeType === 1 && node.classList && node.classList.contains('tex-block') && node.getAttribute('data-tex');
            },
            replacement: function (_content, node) {
                const tex = node.getAttribute('data-tex') || '';
                return `\n\n$$\n${tex}\n$$\n\n`;
            }
        });

        marked.use({ 
            breaks: true, 
            gfm: true,
            pedantic: false,
            smartLists: true
        });

        window.onload = () => {
            convertMdToPreview();
            updateFilenameFromContent();
        };
        
        // 从 Markdown 内容中提取第一个标题作为文件名
        function extractTitleFromMarkdown(text) {
            const lines = text.split('\n');
            for (let line of lines) {
                const trimmed = line.trim();
                // 匹配 # 标题
                const match = trimmed.match(/^#+\s+(.+)$/);
                if (match) {
                    return match[1].trim();
                }
            }
            return null;
        }
        
        // 生成默认文件名（使用日期时间）
        function generateDefaultFilename() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            return `文档_${year}${month}${day}_${hour}${minute}`;
        }
        
        // 清理文件名中的非法字符
        function sanitizeFilename(filename) {
            // 移除或替换 Windows/Mac 文件名中的非法字符
            return filename.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').trim();
        }
        
        // 从内容更新文件名
        function updateFilenameFromContent() {
            if (filenameInput.value.trim()) return; // 如果用户已输入，不自动更新
            
            const text = mdInput.value;
            const title = extractTitleFromMarkdown(text);
            
            if (title) {
                filenameInput.value = sanitizeFilename(title);
            } else {
                filenameInput.value = generateDefaultFilename();
            }
        }
        
        // 获取文件名（如果用户未输入，使用智能提取或默认名称）
        function getFilename() {
            let filename = filenameInput.value.trim();
            
            if (!filename) {
                // 尝试从标题提取
                const title = extractTitleFromMarkdown(mdInput.value);
                filename = title ? sanitizeFilename(title) : generateDefaultFilename();
                filenameInput.value = filename;
            }
            
            return sanitizeFilename(filename);
        }
        
        // 监听 Markdown 输入变化，自动更新文件名
        let updateTimeout;
        mdInput.addEventListener('input', () => {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                if (!filenameInput.value.trim()) {
                    updateFilenameFromContent();
                }
            }, 1000); // 1秒后自动更新
        });
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        function convertMdToPreview() {
            const md = mdInput.value;
            wordPage.innerHTML = marked.parse(md);
            // 把文本节点里的 $...$ / $$...$$ 包起来，并用 MathJax 渲染（避免破坏 turndown 的可逆性）
            wrapMathInDom(wordPage);
            renderMathInPreview(wordPage);
            showToast('预览已更新');
        }

        function convertPreviewToMd() {
            const html = wordPage.innerHTML;
            mdInput.value = turndownService.turndown(html);
            showToast('Markdown 已更新');
        }

        function downloadMarkdown() {
            const filename = getFilename();
            const blob = new Blob([mdInput.value], {type: "text/plain;charset=utf-8"});
            saveAs(blob, filename + ".md");
            showToast('Markdown 导出成功');
        }

        // 全局计数器
        let numberingIdCounter = 0;
        
        // 每级缩进的基准值 (twips)
        // 720 twips = 0.5 inch，这是 Word 默认的列表缩进单位
        const INDENT_PER_LEVEL = 720;

        async function downloadDocx() {
            const text = mdInput.value;
            if (!text.trim()) return;

            await ensureMathJaxReady();
            
            numberingIdCounter = 0;
            const numberingConfigs = [];
            
            const tokens = marked.lexer(text);
            const mathCache = new Map(); // key: `${display ? 1 : 0}:${latex}` -> { data: Uint8Array, width: number, height: number }
            const docNodes = await mapTokensToDocx(tokens, 0, numberingConfigs, mathCache);

            const doc = new docx.Document({
                styles: {
                    default: {
                        document: {
                            run: { font: "Microsoft YaHei", size: 24, color: "000000" },
                            paragraph: { spacing: { line: 360, lineRule: "auto" } }
                        },
                        heading1: {
                            run: { font: "Microsoft YaHei", size: 44, bold: true, color: "000000" },
                            paragraph: { spacing: { before: 480, after: 240 } }
                        },
                        heading2: {
                            run: { font: "Microsoft YaHei", size: 32, bold: true, color: "000000" },
                            paragraph: { spacing: { before: 480, after: 240 } }
                        },
                        heading3: {
                            run: { font: "Microsoft YaHei", size: 28, bold: true, color: "000000" },
                            paragraph: { spacing: { before: 240, after: 120 } }
                        },
                        heading4: {
                            run: { font: "Microsoft YaHei", size: 24, bold: true, color: "000000", italics: false },
                            paragraph: { spacing: { before: 200, after: 100 } }
                        },
                        heading5: {
                            run: { font: "Microsoft YaHei", size: 24, bold: true, color: "000000", italics: false },
                            paragraph: { spacing: { before: 200, after: 100 } }
                        },
                        heading6: {
                            run: { font: "Microsoft YaHei", size: 24, bold: true, color: "000000", italics: false },
                            paragraph: { spacing: { before: 200, after: 100 } }
                        }
                    }
                },
                numbering: {
                    config: numberingConfigs
                },
                sections: [{ children: docNodes }]
            });
            
            docx.Packer.toBlob(doc).then(blob => {
                const filename = getFilename();
                saveAs(blob, filename + ".docx");
                showToast('Word 导出成功');
            });
        }

        // 为每个有序列表生成唯一的编号配置，并根据层级设置正确的缩进
        function createNumberingConfig(level) {
            const id = `numbering-${numberingIdCounter++}`;
            
            // 关键修复：缩进量 = (层级 + 1) * 每级缩进基准
            // level 0 -> 720 twips
            // level 1 -> 1440 twips
            // level 2 -> 2160 twips
            const leftIndent = (level + 1) * INDENT_PER_LEVEL;
            const hangingIndent = 360; // 悬挂缩进，让编号和文字对齐
            
            return {
                id: id,
                config: {
                    reference: id,
                    levels: [
                        { 
                            level: 0, 
                            format: "decimal", 
                            text: "%1.", 
                            alignment: "start", 
                            style: { 
                                paragraph: { 
                                    indent: { 
                                        left: leftIndent, 
                                        hanging: hangingIndent 
                                    } 
                                } 
                            } 
                        }
                    ]
                }
            };
        }

        async function mapTokensToDocx(tokens, listLevel = 0, numberingConfigs = [], mathCache = new Map()) {
            const children = [];

            for (const token of tokens) {
                if (token.type === 'heading') {
                    const runs = token.tokens ? await parseInlineText(token, { bold: false, italics: false, color: undefined }, mathCache) : [new docx.TextRun({ text: token.text })];
                    children.push(new docx.Paragraph({
                        children: runs,
                        heading: getHeadingLevel(token.depth)
                    }));
                }
                else if (token.type === 'paragraph') {
                    const paragraphText = (token.text || '').trim();
                    const isDisplayMathOnly = paragraphText.startsWith('$$') && paragraphText.endsWith('$$') && paragraphText.length >= 4;
                    if (isDisplayMathOnly) {
                        const latex = paragraphText.slice(2, -2).trim();
                        const imgRun = await createMathImageRun(latex, true, mathCache);
                        children.push(new docx.Paragraph({
                            children: [imgRun],
                            alignment: docx.AlignmentType.CENTER,
                            spacing: { after: 200 }
                        }));
                    } else {
                        children.push(new docx.Paragraph({
                            children: await parseInlineText(token, { bold: false, italics: false, color: undefined }, mathCache),
                            spacing: { after: 200 },
                            indent: { firstLine: 480 }
                        }));
                    }
                }
                else if (token.type === 'list') {
                    const isOrdered = token.ordered;
                    
                    // 为每个有序列表创建独立的编号配置
                    let currentNumberingRef = null;
                    if (isOrdered) {
                        const numConfig = createNumberingConfig(listLevel);
                        numberingConfigs.push(numConfig.config);
                        currentNumberingRef = numConfig.id;
                    }
                    
                    for (const item of token.items) {
                        if (!item.tokens) return;

                        let hasRenderedBullet = false;

                        for (const t of item.tokens) {
                            if (t.type === 'list') {
                                // 递归处理嵌套列表，层级 +1
                                const nestedChildren = await mapTokensToDocx([t], listLevel + 1, numberingConfigs, mathCache);
                                children.push(...nestedChildren);
                            } 
                            else if (t.type === 'paragraph' || t.type === 'text') {
                                const runs = await parseInlineText(t, { bold: false, italics: false, color: undefined }, mathCache);
                                const pOptions = {
                                    children: runs,
                                    spacing: { after: 100 }
                                };

                                if (!hasRenderedBullet) {
                                    if (isOrdered) {
                                        // 有序列表：使用独立的编号引用
                                        pOptions.numbering = { reference: currentNumberingRef, level: 0 };
                                    } else {
                                        // 无序列表：使用 bullet，level 对应当前层级
                                        pOptions.bullet = { level: listLevel };
                                    }
                                    hasRenderedBullet = true;
                                } else {
                                    // 列表项内的后续段落：添加相应缩进
                                    pOptions.indent = { left: (listLevel + 1) * INDENT_PER_LEVEL };
                                }
                                children.push(new docx.Paragraph(pOptions));
                            }
                            else if (t.type === 'blockquote') {
                                const runs = t.tokens ? await parseInlineText(t, { bold: false, italics: false, color: undefined }, mathCache) : [new docx.TextRun({ text: t.text })];
                                children.push(new docx.Paragraph({
                                    children: runs,
                                    indent: { left: (listLevel + 1) * INDENT_PER_LEVEL + 480 },
                                    border: { left: { color: "dddddd", space: 10, value: "single", size: 24 } },
                                    spacing: { after: 200 }
                                }));
                            }
                            else if (t.type === 'table') {
                                const tableNodes = await mapTokensToDocx([t], listLevel, numberingConfigs, mathCache); 
                                children.push(...tableNodes);
                            }
                        }
                    }
                }
                else if (token.type === 'table') {
                    const tableRows = [];
                    // 表头单元格（支持内联公式）：异步构建
                    const headerCells = [];
                    for (const h of token.header) {
                        const runs = h.tokens
                            ? await parseInlineText(h, { bold: true, italics: false, color: undefined }, mathCache)
                            : [new docx.TextRun({ text: h.text, bold: true })];
                        headerCells.push(new docx.TableCell({
                            children: [new docx.Paragraph({ children: runs, alignment: "center" })],
                            shading: { fill: "f3f4f6" },
                        }));
                    }
                    tableRows.push(new docx.TableRow({ children: headerCells }));
                    for (const row of token.rows) {
                        const cells = [];
                        for (const cell of row) {
                            const runs = cell.tokens
                                ? await parseInlineText(cell, { bold: false, italics: false, color: undefined }, mathCache)
                                : [new docx.TextRun({ text: cell.text })];
                            cells.push(new docx.TableCell({
                                children: [new docx.Paragraph({ children: runs, alignment: "center" })]
                            }));
                        }
                        tableRows.push(new docx.TableRow({ children: cells }));
                    }
                    children.push(new docx.Table({
                        rows: tableRows, width: { size: 100, type: "pct" }, spacing: { after: 200 }
                    }));
                }
                else if (token.type === 'blockquote') {
                    const runs = token.tokens ? await parseInlineText(token, { bold: false, italics: false, color: undefined }, mathCache) : [new docx.TextRun({ text: token.text })];
                    children.push(new docx.Paragraph({
                        children: runs, 
                        indent: { left: 480 }, 
                        border: { left: { color: "dddddd", space: 10, value: "single", size: 24 } },
                        spacing: { after: 200 }
                    }));
                }
            }
            return children;
        }

        function getHeadingLevel(depth) {
            switch (depth) {
                case 1: return docx.HeadingLevel.HEADING_1;
                case 2: return docx.HeadingLevel.HEADING_2;
                case 3: return docx.HeadingLevel.HEADING_3;
                case 4: return docx.HeadingLevel.HEADING_4;
                case 5: return docx.HeadingLevel.HEADING_5;
                default: return docx.HeadingLevel.HEADING_6;
            }
        }

        async function parseInlineText(token, style = { bold: false, italics: false, color: undefined }, mathCache = new Map()) {
            if (!token.tokens) {
                return await parseInlineTextFromString(token.text || "", style, mathCache);
            }

            const runs = [];
            for (const t of token.tokens) {
                if (t.type === 'strong') {
                    runs.push(...await parseInlineText(t, { ...style, bold: true }, mathCache));
                } else if (t.type === 'em') {
                    runs.push(...await parseInlineText(t, { ...style, italics: true }, mathCache));
                } else if (t.type === 'link') {
                    runs.push(...await parseInlineText(t, { ...style, color: "0563C1" }, mathCache));
                } else if (t.type === 'codespan') {
                    runs.push(new docx.TextRun({ text: t.text || "", font: "Consolas", ...style }));
                } else if (t.type === 'text') {
                    if (t.tokens && t.tokens.length > 0) {
                        runs.push(...await parseInlineText(t, style, mathCache));
                    } else {
                        runs.push(...await parseInlineTextFromString(t.text || "", style, mathCache));
                    }
                } else {
                    const text = (t.tokens && t.tokens.length > 0) ? extractTextFromTokens(t.tokens) : (t.text || "");
                    runs.push(...await parseInlineTextFromString(text, style, mathCache));
                }
            }
            return runs;
        }

        async function parseInlineTextFromString(text, style, mathCache) {
            const segments = splitTextAndMath(text || "");
            const runs = [];
            for (const seg of segments) {
                if (seg.type === 'text') {
                    if (seg.value) runs.push(new docx.TextRun({ text: seg.value, ...style }));
                } else if (seg.type === 'math') {
                    try {
                        if (!seg.display) {
                            const simple = tryBuildSimpleScriptRunsFromLatex(seg.value, style);
                            if (simple) {
                                runs.push(...simple);
                                continue;
                            }
                        }
                        runs.push(await createMathImageRun(seg.value, seg.display, mathCache));
                    } catch (e) {
                        const fallback = seg.display ? `$$${seg.value}$$` : `$${seg.value}$`;
                        runs.push(new docx.TextRun({ text: fallback, ...style }));
                    }
                }
            }
            return runs;
        }

        function splitTextAndMath(input) {
            const s = String(input || "");
            const out = [];
            let i = 0;

            const pushText = (v) => { if (v) out.push({ type: 'text', value: v }); };

            while (i < s.length) {
                const ch = s[i];
                if (ch === '\\' && s[i + 1] === '$') {
                    pushText('$');
                    i += 2;
                    continue;
                }

                if (ch === '$') {
                    const isDouble = s[i + 1] === '$';
                    const delim = isDouble ? '$$' : '$';
                    const start = i + delim.length;
                    let j = start;
                    while (j < s.length) {
                        if (s[j] === '\\' && s[j + 1] === '$') { j += 2; continue; }
                        if (isDouble) {
                            if (s[j] === '$' && s[j + 1] === '$') break;
                        } else {
                            if (s[j] === '$') break;
                        }
                        j++;
                    }

                    const found = isDouble ? (j < s.length - 1 && s[j] === '$' && s[j + 1] === '$') : (j < s.length && s[j] === '$');
                    if (found) {
                        const latex = s.slice(start, j).trim();
                        out.push({ type: 'math', value: latex, display: isDouble });
                        i = j + delim.length;
                        continue;
                    }
                }

                let k = i;
                while (k < s.length) {
                    if (s[k] === '\\' && s[k + 1] === '$') break;
                    if (s[k] === '$') break;
                    k++;
                }
                pushText(s.slice(i, k));
                i = k;
            }

            return out.length ? out : [{ type: 'text', value: s }];
        }

        async function ensureMathJaxReady() {
            if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                await window.MathJax.startup.promise;
                return;
            }
            await new Promise((resolve, reject) => {
                const start = Date.now();
                const timer = setInterval(() => {
                    if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                        clearInterval(timer);
                        window.MathJax.startup.promise.then(resolve).catch(reject);
                        return;
                    }
                    if (Date.now() - start > 15000) {
                        clearInterval(timer);
                        reject(new Error("MathJax 加载超时"));
                    }
                }, 100);
            });
        }

        async function createMathImageRun(latex, displayMode, mathCache) {
            const key = `${displayMode ? 1 : 0}:${latex}`;
            const cached = mathCache.get(key);
            if (cached) {
                return new docx.ImageRun({
                    data: cached.data,
                    transformation: { width: cached.width, height: cached.height }
                });
            }

            const svg = latexToSvgElement(latex, displayMode);
            const viewBox = svg.getAttribute('viewBox') || '0 0 100 20';
            const vb = viewBox.split(/\s+/).map(Number);
            const vbW = (vb.length >= 4 && isFinite(vb[2])) ? vb[2] : 100;
            const vbH = (vb.length >= 4 && isFinite(vb[3])) ? vb[3] : 20;

            const targetH = displayMode ? 34 : 18;
            const targetW = Math.max(1, Math.round(targetH * (vbW / vbH)));

            svg.setAttribute('width', `${targetW}px`);
            svg.setAttribute('height', `${targetH}px`);

            const data = await svgToPngBytes(svg, targetW, targetH);

            const record = { data, width: targetW, height: targetH };
            mathCache.set(key, record);

            return new docx.ImageRun({
                data: record.data,
                transformation: { width: record.width, height: record.height }
            });
        }

        function latexToSvgElement(latex, displayMode) {
            const node = window.MathJax.tex2svg(latex, { display: !!displayMode });
            const svg = node.querySelector('svg');
            if (!svg) throw new Error("MathJax 未生成 SVG");
            return svg;
        }

        async function blobToUint8Array(blob) {
            const buf = await blob.arrayBuffer();
            return new Uint8Array(buf);
        }

        async function svgToPngBytes(svgElement, width, height) {
            const svgClone = svgElement.cloneNode(true);
            svgClone.removeAttribute('style');
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            svgClone.setAttribute('width', `${width}`);
            svgClone.setAttribute('height', `${height}`);

            const svgText = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            try {
                const img = await new Promise((resolve, reject) => {
                    const image = new Image();
                    image.onload = () => resolve(image);
                    image.onerror = reject;
                    image.src = url;
                });

                const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
                const canvas = document.createElement('canvas');
                canvas.width = width * dpr;
                canvas.height = height * dpr;

                const ctx = canvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0, width, height);

                const pngBlob = await new Promise((resolve, reject) => {
                    canvas.toBlob((b) => (b ? resolve(b) : reject(new Error("canvas.toBlob 失败"))), 'image/png');
                });
                return await blobToUint8Array(pngBlob);
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function tryBuildSimpleScriptRunsFromLatex(latex, style) {
            const s = String(latex || '').trim();
            const m = s.match(/^([A-Za-z0-9])(?:_\{([^{}]+)\})?(?:\^\{([^{}]+)\})?$/);
            if (!m) return null;
            const base = m[1];
            const sub = m[2];
            const sup = m[3];

            const runs = [new docx.TextRun({ text: base, ...style })];
            if (sub) runs.push(new docx.TextRun({ text: sub, subScript: true, ...style }));
            if (sup) runs.push(new docx.TextRun({ text: sup, superScript: true, ...style }));
            return runs;
        }

        function wrapMathInDom(root) {
            if (!root) return;
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (!node || !node.nodeValue || node.nodeValue.indexOf('$') === -1) return NodeFilter.FILTER_REJECT;
                    const p = node.parentNode;
                    if (!p) return NodeFilter.FILTER_REJECT;
                    const tag = (p.nodeName || '').toUpperCase();
                    if (tag === 'CODE' || tag === 'PRE' || tag === 'SCRIPT' || tag === 'STYLE') return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });

            const textNodes = [];
            let cur;
            while ((cur = walker.nextNode())) textNodes.push(cur);

            for (const node of textNodes) {
                const segments = splitTextAndMath(node.nodeValue || "");
                if (!segments.some(s => s.type === 'math')) continue;

                const frag = document.createDocumentFragment();
                for (const seg of segments) {
                    if (seg.type === 'text') {
                        frag.appendChild(document.createTextNode(seg.value || ""));
                    } else {
                        const el = document.createElement(seg.display ? 'div' : 'span');
                        el.className = seg.display ? 'tex-block' : 'tex-inline';
                        el.setAttribute('data-tex', seg.value || "");
                        el.textContent = seg.display ? `$$${seg.value}$$` : `$${seg.value}$`;
                        frag.appendChild(el);
                    }
                }
                node.parentNode.replaceChild(frag, node);
            }
        }

        async function renderMathInPreview(root) {
            try {
                await ensureMathJaxReady();
            } catch {
                return;
            }
            if (!root) return;
            const nodes = root.querySelectorAll('.tex-inline[data-tex], .tex-block[data-tex]');
            for (const n of nodes) {
                const latex = n.getAttribute('data-tex') || '';
                const displayMode = n.classList.contains('tex-block');
                try {
                    const svg = latexToSvgElement(latex, displayMode);
                    n.innerHTML = '';
                    n.appendChild(svg);
                } catch {
                    // ignore
                }
            }
        }

        // 辅助函数：从 tokens 数组中递归提取纯文本
        function extractTextFromTokens(tokens) {
            if (!tokens || tokens.length === 0) return '';
            let text = '';
            tokens.forEach(t => {
                if (t.text) {
                    text += t.text;
                }
                if (t.tokens && t.tokens.length > 0) {
                    text += extractTextFromTokens(t.tokens);
                }
            });
            return text;
        }
    </script>
</body>
</html>