<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown ↔ Word 完美版</title>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <script src="https://unpkg.com/turndown-plugin-gfm/dist/turndown-plugin-gfm.js"></script>

    <!-- MathJax: 用于渲染 LaTeX 数学公式（$...$ / $$...$$） -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <!-- 初始化库加载状态追踪 -->
    <script>
        window.__libs_loading = { jszip: false, temml: false, mathml2omml: false };
    </script>

    <!-- JSZip：用于对生成的 docx（zip）做二次注入（OMML/隐藏 Markdown） -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" 
            onload="window.__libs_loading.jszip = true; console.log('✓ JSZip 加载成功');"
            onerror="window.__libs_loading.jszip = 'error'; console.error('✗ JSZip 加载失败');"></script>

    <!-- Temml：LaTeX -> MathML（轻量，适合生成 OMML 前置 MathML）
         使用 temml.js（非 min 版）确保更好的兼容性 -->
    <script src="https://cdn.jsdelivr.net/npm/temml@0.12.1/dist/temml.js" 
            onload="window.__libs_loading.temml = true; console.log('✓ Temml 加载成功', typeof window.temml);"
            onerror="window.__libs_loading.temml = 'error'; console.error('✗ Temml 加载失败');"></script>

    <!-- mathml2omml：MathML -> OMML（Word 可编辑公式）
         注意：mathml2omml 的 dist 文件是 ESM（含 export），必须用 module 加载；加载后我们挂到 window 供主脚本使用 -->
    <script type="module">
        import("https://cdn.jsdelivr.net/npm/mathml2omml@0.5.0/dist/index.esm.js")
            .then((mod) => {
                // 主逻辑使用 window.mml2omml / window.MML2OMML
                window.mml2omml = mod.mml2omml;
                window.MML2OMML = mod.MML2OMML;
                window.__libs_loading.mathml2omml = true;
                console.log('✓ mathml2omml 加载成功');
            })
            .catch((err) => {
                console.error("✗ mathml2omml 加载失败：", err);
                window.__mathml2omml_load_error = err;
                window.__libs_loading.mathml2omml = 'error';
            });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/docx@7.1.0/build/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <style>
        :root { --primary: #2563eb; --bg: #f3f4f6; --border: #d1d5db; --toolbar-h: 60px; }
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: "Microsoft YaHei", sans-serif; background: var(--bg);
            height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        header {
            height: var(--toolbar-h); background: white; border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); z-index: 10;
        }

        h1 { font-size: 18px; color: #374151; display: flex; align-items: center; gap: 10px; }
        .controls { display: flex; align-items: center; gap: 15px; }
        .filename-group { display: flex; align-items: center; gap: 8px; }
        .filename-group label { font-size: 14px; color: #6b7280; white-space: nowrap; }
        .filename-group input { 
            padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px;
            font-size: 14px; width: 200px; outline: none; transition: all 0.2s;
        }
        .filename-group input:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }
        .filename-group input::placeholder { color: #9ca3af; }
        .btn-group { display: flex; gap: 10px; }
        button {
            padding: 8px 16px; border: 1px solid var(--border); background: white;
            border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; 
            align-items: center; gap: 6px; color: #374151; transition: all 0.2s;
        }
        button:hover { background: #f9fafb; border-color: #9ca3af; }
        button.primary { background: var(--primary); color: white; border-color: var(--primary); }
        button.primary:hover { background: #1d4ed8; }

        .main { flex: 1; display: flex; height: calc(100vh - var(--toolbar-h)); }
        .pane { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .editor-container { flex: 1; background: #1e1e1e; position: relative; }
        textarea {
            width: 100%; height: 100%; background: #1e1e1e; color: #e5e7eb;
            border: none; resize: none; padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace; font-size: 14px; line-height: 1.6; outline: none;
        }
        .pane-label {
            background: #f3f4f6; padding: 8px 15px; font-size: 12px; color: #666;
            border-bottom: 1px solid var(--border); border-top: 1px solid var(--border);
        }
        .gutter {
            width: 60px; background: #e5e7eb; border-left: 1px solid var(--border); 
            border-right: 1px solid var(--border); display: flex; flex-direction: column; 
            justify-content: center; align-items: center; gap: 20px; z-index: 5;
        }
        .action-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 1px solid #ccc;
            background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 20px;
            color: var(--primary); transition: transform 0.2s;
        }
        .action-btn:hover { transform: scale(1.1); color: #1d4ed8; border-color: var(--primary); }
        
        .preview-container {
            flex: 1; background: #e0e0e0; overflow-y: auto; padding: 30px; display: block; 
        }

        #word-page {
            background: white; width: 21cm; min-height: 29.7cm; padding: 2.54cm;
            box-shadow: 0 0 10px rgba(0,0,0,0.1); outline: none; color: #000;
            text-align: justify;
            font-family: "Microsoft YaHei", sans-serif; font-size: 12pt; line-height: 1.5;
            margin: 0 auto 50px auto; height: auto; overflow: visible;
        }

        #word-page h1 { font-size: 22pt; margin: 24pt 0 12pt; font-weight: bold; color: #000; }
        #word-page h2 { font-size: 16pt; margin: 24pt 0 12pt; font-weight: bold; color: #000; }
        #word-page h3 { font-size: 14pt; margin: 12pt 0 6pt; font-weight: bold; color: #000; }
        #word-page h4 { font-size: 12pt; margin: 10pt 0 6pt; font-weight: bold; color: #000; font-style: normal; }
        #word-page h5 { font-size: 12pt; margin: 10pt 0 6pt; font-weight: bold; color: #000; font-style: normal; }
        #word-page h6 { font-size: 12pt; margin: 10pt 0 6pt; font-weight: bold; color: #000; font-style: normal; }
        
        #word-page p { margin: 0 0 10pt; text-indent: 2em; }
        
        #word-page ul, #word-page ol { margin: 0 0 10pt; padding-left: 2em; text-indent: 0; }
        #word-page li { margin-bottom: 0; list-style-position: outside; }
        #word-page li p { text-indent: 0; margin-bottom: 0; }
        #word-page ul ul, #word-page ol ul, #word-page ul ol, #word-page ol ol {
            margin-top: 0; margin-bottom: 0;
        }

        #word-page blockquote { border-left: 4px solid #ddd; padding-left: 12pt; color: #555; margin: 0 0 10pt 0; }
        #word-page blockquote p { text-indent: 0; }

        #word-page table { border-collapse: collapse; width: 100%; margin-bottom: 10pt; text-indent: 0; }
        #word-page th, #word-page td { border: 1px solid #000; padding: 8px; text-align: center; font-size: 10.5pt; }
        #word-page th { background-color: #f3f4f6; font-weight: bold; }

        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
            border-radius: 20px; font-size: 14px; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; z-index: 100;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

    <header>
        <h1><span>MD ↔ Word 最终版</span></h1>
        <div class="controls">
            <div class="filename-group">
                <label for="filename">文件名：</label>
                <input type="text" id="filename" placeholder="自动提取或输入..." title="留空则自动从第一个标题提取，或使用日期时间" />
            </div>
            <div class="btn-group">
                <button onclick="downloadMarkdown()">导出 Markdown</button>
                <button onclick="triggerDocxImport()">导入 Word (.docx)</button>
                <button class="primary" onclick="downloadDocx()">导出 Word (.docx)</button>
            </div>
        </div>
    </header>

    <div class="main">
        <div class="pane" style="border-right: 1px solid #ccc;">
            <div class="pane-label">Markdown 源码</div>
            <div class="editor-container">
                <textarea id="md-input" placeholder="在此输入 Markdown..."># 嵌套列表测试

## 测试加粗和斜体

* 外层列表项 1
* 外层列表项 2
  * 嵌套列表项 A（包含**加粗文本**）
  * 嵌套列表项 B（包含*斜体文本*）
  * 嵌套列表项 C（包含**塔坛缘分墙**）
  * 嵌套列表项 D（包含**"案例分析" 和 "情景模拟"**）
* 外层列表项 3

## 测试有序列表

1. 第一项
2. 第二项
   - 嵌套的无序列表 A
   - 嵌套的无序列表 B（**加粗内容**）
     1. 三级有序列表
     2. 继续测试
   - 嵌套的无序列表 C
     1. 新的三级有序列表（应该从1开始）
     2. 继续
3. 第三项

                </textarea>
            </div>
        </div>

        <div class="gutter">
            <div class="action-btn" onclick="convertMdToPreview()">➡</div>
            <div class="action-btn" onclick="convertPreviewToMd()">⬅</div>
        </div>

        <div class="pane">
            <div class="pane-label">Word 预览 / 粘贴区</div>
            <div class="preview-container">
                <div id="word-page" contenteditable="true"></div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast">操作成功</div>
    <input id="docx-input" type="file" accept=".docx" style="display:none" />

    <script>
        const mdInput = document.getElementById('md-input');
        const wordPage = document.getElementById('word-page');
        const filenameInput = document.getElementById('filename');
        const docxInput = document.getElementById('docx-input');
        
        const turndownService = new TurndownService({ headingStyle: 'atx', bulletListMarker: '-' });
        const gfm = turndownPluginGfm.gfm;
        turndownService.use(gfm);

        // turndown：把预览区渲染后的公式节点还原为 $...$ / $$...$$
        turndownService.addRule('tex-inline', {
            filter: function (node) {
                return node.nodeType === 1 && node.classList && node.classList.contains('tex-inline') && node.getAttribute('data-tex');
            },
            replacement: function (_content, node) {
                const tex = node.getAttribute('data-tex') || '';
                return `$${tex}$`;
            }
        });
        turndownService.addRule('tex-block', {
            filter: function (node) {
                return node.nodeType === 1 && node.classList && node.classList.contains('tex-block') && node.getAttribute('data-tex');
            },
            replacement: function (_content, node) {
                const tex = node.getAttribute('data-tex') || '';
                return `\n\n$$\n${tex}\n$$\n\n`;
            }
        });

        marked.use({ 
            breaks: true, 
            gfm: true,
            pedantic: false,
            smartLists: true,
            // 保留 HTML 标签（不转义）
            sanitize: false,
            // 允许在表格等块级元素中使用 HTML
            mangle: false,
            headerIds: false
        });

        window.onload = () => {
            convertMdToPreview();
            updateFilenameFromContent();
        };
        
        // 从 Markdown 内容中提取第一个标题作为文件名
        function extractTitleFromMarkdown(text) {
            const lines = text.split('\n');
            for (let line of lines) {
                const trimmed = line.trim();
                // 匹配 # 标题
                const match = trimmed.match(/^#+\s+(.+)$/);
                if (match) {
                    return match[1].trim();
                }
            }
            return null;
        }
        
        // 生成默认文件名（使用日期时间）
        function generateDefaultFilename() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            return `文档_${year}${month}${day}_${hour}${minute}`;
        }
        
        // 清理文件名中的非法字符
        function sanitizeFilename(filename) {
            // 移除或替换 Windows/Mac 文件名中的非法字符
            return filename.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').trim();
        }
        
        // 从内容更新文件名
        function updateFilenameFromContent() {
            if (filenameInput.value.trim()) return; // 如果用户已输入，不自动更新
            
            const text = mdInput.value;
            const title = extractTitleFromMarkdown(text);
            
            if (title) {
                filenameInput.value = sanitizeFilename(title);
            } else {
                filenameInput.value = generateDefaultFilename();
            }
        }
        
        // 获取文件名（如果用户未输入，使用智能提取或默认名称）
        function getFilename() {
            let filename = filenameInput.value.trim();
            
            if (!filename) {
                // 尝试从标题提取
                const title = extractTitleFromMarkdown(mdInput.value);
                filename = title ? sanitizeFilename(title) : generateDefaultFilename();
                filenameInput.value = filename;
            }
            
            return sanitizeFilename(filename);
        }
        
        // 监听 Markdown 输入变化，自动更新文件名
        let updateTimeout;
        mdInput.addEventListener('input', () => {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                if (!filenameInput.value.trim()) {
                    updateFilenameFromContent();
                }
            }, 1000); // 1秒后自动更新
        });
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        // 清理不可见的零宽字符（常见于从某些编辑器/IM 粘贴），否则会导致 **...** 配对失败/错配
        // 例如：看起来是 "**"，实际是 "*\u200b*"，会出现“中间被加粗，两端 ** 当文本输出”的现象
        function stripZeroWidthChars(text) {
            return String(text || '').replace(/[\u200B-\u200D\uFEFF]/g, '');
        }

        // 预览专用：在进入 marked 之前，对“宽松 **...** 加粗”做一次文本级预处理
        // 目的：避免 marked 在某些中文标点场景下把 ** 拆成跨节点残留，进而被 DOM 兜底逻辑误包裹（出现中间普通文字也被加粗）
        // 规则：
        // - 仅在非代码块/非行内代码范围内处理
        // - 仅当本行 ** 数量为偶数时才替换（避免误配）
        // - 不跨行配对
        function preprocessLooseBoldForPreview(markdown) {
            const src = stripZeroWidthChars(String(markdown || '').replace(/\r\n/g, '\n'));
            const lines = src.split('\n');
            let inFence = false;
            let fenceTickCount = 0;

            const processLine = (line) => {
                // 统计本行（排除行内代码）中的 ** 数量
                let inCode = false;
                let codeDelim = '';
                let count = 0;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (ch === '`') {
                        // 取连续反引号作为 delimiter
                        let j = i;
                        while (j < line.length && line[j] === '`') j++;
                        const delim = line.slice(i, j);
                        if (!inCode) {
                            inCode = true; codeDelim = delim;
                        } else if (delim === codeDelim) {
                            inCode = false; codeDelim = '';
                        }
                        i = j - 1;
                        continue;
                    }
                    if (!inCode && ch === '*' && line[i + 1] === '*') {
                        count++;
                        i++;
                    }
                }
                if (count < 2 || (count % 2) === 1) return line;

                // 替换：遇到 ** 就 toggle <strong>
                inCode = false;
                codeDelim = '';
                let bold = false;
                let out = '';
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (ch === '`') {
                        let j = i;
                        while (j < line.length && line[j] === '`') j++;
                        const delim = line.slice(i, j);
                        if (!inCode) {
                            inCode = true; codeDelim = delim;
                        } else if (delim === codeDelim) {
                            inCode = false; codeDelim = '';
                        }
                        out += delim;
                        i = j - 1;
                        continue;
                    }
                    if (!inCode && ch === '*' && line[i + 1] === '*') {
                        out += (bold ? '</strong>' : '<strong>');
                        bold = !bold;
                        i++;
                        continue;
                    }
                    out += ch;
                }
                // 保守兜底：如果出现未闭合，回退原行
                if (bold) return line;
                return out;
            };

            const out = [];
            for (const line of lines) {
                const trimmed = line.trimStart();
                if (trimmed.startsWith('```')) {
                    // 进入/退出代码块（按连续 ``` 的数量粗略匹配）
                    const m = trimmed.match(/^(`{3,})/);
                    const ticks = m ? m[1].length : 3;
                    if (!inFence) {
                        inFence = true; fenceTickCount = ticks;
                    } else if (ticks >= fenceTickCount) {
                        inFence = false; fenceTickCount = 0;
                    }
                    out.push(line);
                    continue;
                }
                out.push(inFence ? line : processLine(line));
            }
            return out.join('\n');
        }

        // 导出 Word 专用：把 **...** 预处理成“显式开/关”标记，避免 marked 的强调解析偶发错配导致导出的加粗范围不正确
        // - 使用私有区字符作为标记（不会在 Word 中显示）
        // - 不处理代码块/行内代码
        // - 不跨行配对；单行 ** 数量为偶数才替换
        const DOCX_BOLD_OPEN = '\uE000';
        const DOCX_BOLD_CLOSE = '\uE001';
        function preprocessLooseBoldForDocx(markdown) {
            const src = stripZeroWidthChars(String(markdown || '').replace(/\r\n/g, '\n'));
            const lines = src.split('\n');
            let inFence = false;
            let fenceTickCount = 0;

            const countBoldMarkersInLine = (line) => {
                let inCode = false;
                let codeDelim = '';
                let count = 0;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (ch === '`') {
                        let j = i;
                        while (j < line.length && line[j] === '`') j++;
                        const delim = line.slice(i, j);
                        if (!inCode) { inCode = true; codeDelim = delim; }
                        else if (delim === codeDelim) { inCode = false; codeDelim = ''; }
                        i = j - 1;
                        continue;
                    }
                    if (!inCode && ch === '*' && line[i + 1] === '*') { count++; i++; }
                }
                return count;
            };

            const processLine = (line) => {
                const count = countBoldMarkersInLine(line);
                if (count < 2 || (count % 2) === 1) return line;

                let inCode = false;
                let codeDelim = '';
                let bold = false;
                let out = '';
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (ch === '`') {
                        let j = i;
                        while (j < line.length && line[j] === '`') j++;
                        const delim = line.slice(i, j);
                        if (!inCode) { inCode = true; codeDelim = delim; }
                        else if (delim === codeDelim) { inCode = false; codeDelim = ''; }
                        out += delim;
                        i = j - 1;
                        continue;
                    }
                    if (!inCode && ch === '*' && line[i + 1] === '*') {
                        out += (bold ? DOCX_BOLD_CLOSE : DOCX_BOLD_OPEN);
                        bold = !bold;
                        i++;
                        continue;
                    }
                    out += ch;
                }
                if (bold) return line; // 未闭合则回退
                return out;
            };

            const out = [];
            for (const line of lines) {
                const trimmed = line.trimStart();
                if (trimmed.startsWith('```')) {
                    const m = trimmed.match(/^(`{3,})/);
                    const ticks = m ? m[1].length : 3;
                    if (!inFence) { inFence = true; fenceTickCount = ticks; }
                    else if (ticks >= fenceTickCount) { inFence = false; fenceTickCount = 0; }
                    out.push(line);
                    continue;
                }
                out.push(inFence ? line : processLine(line));
            }
            return out.join('\n');
        }

        docxInput.addEventListener('change', async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            try {
                await importDocxFile(file);
                showToast('Word 导入成功');
            } catch (err) {
                console.error(err);
                showToast('Word 导入失败（详见控制台）');
            } finally {
                // 允许重复选择同一个文件触发 change
                docxInput.value = '';
            }
        });

        function triggerDocxImport() {
            docxInput.click();
        }

        function convertMdToPreview() {
            // 预览：先做“宽松加粗”文本预处理，避免 DOM 兜底误加粗
            const mdRaw = preprocessLooseBoldForPreview(mdInput.value);
            // 修复：表格单元格内存在“真实空行”会导致 marked 认为表格结束，从而表格后半段跑出表格
            // 这里先把表格块里被换行拆断的行拼回单行（保留 <br>），保证 marked 正确产出 table token
            const md = normalizeMarkdownTables(mdRaw);
            wordPage.innerHTML = marked.parse(md);
            // 如果预览 HTML 里仍残留 **（极少数情况），再做一次 DOM 兜底；否则不做，避免误包裹
            if (wordPage.innerHTML.includes('**')) {
                wrapLooseBoldInDom(wordPage);
            }
            // 把文本节点里的 $...$ / $$...$$ 包起来，并用 MathJax 渲染（避免破坏 turndown 的可逆性）
            wrapMathInDom(wordPage);
            renderMathInPreview(wordPage);
            showToast('预览已更新');
        }

        function convertPreviewToMd() {
            const html = wordPage.innerHTML;
            mdInput.value = turndownService.turndown(html);
            showToast('Markdown 已更新');
        }

        function downloadMarkdown() {
            const filename = getFilename();
            const blob = new Blob([mdInput.value], {type: "text/plain;charset=utf-8"});
            saveAs(blob, filename + ".md");
            showToast('Markdown 导出成功');
        }

        // 修复：把表格块中“被换行拆断的表格行”重新拼成单行
        // 典型输入（单元格里写了 <br> 后又留了空行）：
        // | A | xxx<br>
        //
        // <br>yyy |
        // marked 会把空行当作表格结束，导致后续内容跑出表格。
        // 本函数在不改变表意的前提下，把同一行重新拼回：
        // | A | xxx<br><br>yyy |
        function normalizeMarkdownTables(markdown) {
            const src = String(markdown || '').replace(/\r\n/g, '\n');
            const lines = src.split('\n');

            const countTableCols = (line) => {
                const s = String(line || '').trim();
                if (!s.includes('|')) return 0;
                let parts = s.split('|');
                // 去掉因首尾竖线导致的空单元格
                if (parts.length && parts[0].trim() === '') parts = parts.slice(1);
                if (parts.length && parts[parts.length - 1].trim() === '') parts = parts.slice(0, -1);
                return parts.length;
            };

            const isTableSep = (line) => {
                // 允许：| --- | --- | / |:---|---:| 等
                const s = String(line || '').trim();
                return /^\|?\s*:?-{3,}:?\s*(\|\s*:?-{3,}:?\s*)+\|?\s*$/.test(s);
            };
            const isTableHeader = (line) => {
                const s = String(line || '').trim();
                return s.startsWith('|') && s.includes('|');
            };
            const isRowStart = (line) => String(line || '').trim().startsWith('|');
            // 行是否“完整”：不强依赖末尾必须有 '|'（Markdown 允许省略末尾竖线）
            // 用“列数达到表头列数”作为判定，更稳，避免导出时列数不齐导致 Word 里列整体左移（看起来像列错乱）
            const isRowCompleteByCols = (row, expectedCols) => {
                const cols = countTableCols(row);
                return expectedCols > 0 ? (cols >= expectedCols) : String(row || '').trimEnd().endsWith('|');
            };

            const out = [];
            let i = 0;
            while (i < lines.length) {
                const line = lines[i];

                // 识别表格：header + 分隔线
                if (isTableHeader(line) && i + 1 < lines.length && isTableSep(lines[i + 1])) {
                    const expectedCols = countTableCols(line);
                    out.push(line.trimEnd());
                    out.push(lines[i + 1].trimEnd());
                    i += 2;

                    let rowBuf = null;
                    let j = i;

                    while (j < lines.length) {
                        const cur = lines[j];
                        const trimmed = String(cur || '').trim();

                        // 表格结束：遇到空行且当前没有未完成的行
                        if (trimmed === '' && rowBuf === null) break;

                        if (isRowStart(cur)) {
                            // 开始新行：先 flush 旧行（极端情况下）
                            if (rowBuf !== null) {
                                out.push(rowBuf.trimEnd());
                                rowBuf = null;
                            }
                            rowBuf = cur.trimEnd();
                            if (isRowCompleteByCols(rowBuf, expectedCols)) {
                                out.push(rowBuf.trimEnd());
                                rowBuf = null;
                            }
                            j++;
                            continue;
                        }

                        // 续行：拼到上一行的末尾，消除“真实换行”对表格语法的破坏
                        if (rowBuf !== null) {
                            if (trimmed === '') {
                                // 空行：大多数情况下是 <br> 间隔的空白，直接忽略即可
                                // （如果你希望保留空行，可在这里插入 '<br>'）
                            } else {
                                rowBuf += trimmed;
                            }
                            if (isRowCompleteByCols(rowBuf, expectedCols)) {
                                out.push(rowBuf.trimEnd());
                                rowBuf = null;
                            }
                            j++;
                            continue;
                        }

                        // 既不是新行也没有 rowBuf：表格结束（交还给外层处理）
                        break;
                    }

                    if (rowBuf !== null) out.push(rowBuf.trimEnd());
                    i = j;
                    continue;
                }

                out.push(line);
                i++;
            }

            return out.join('\n');
        }
        
        // 全局计数器
        let numberingIdCounter = 0;
        
        // 每级缩进的基准值 (twips)
        // 720 twips = 0.5 inch，这是 Word 默认的列表缩进单位
        const INDENT_PER_LEVEL = 720;

        async function downloadDocx() {
            // 导出侧：先把 **...** 转为显式标记，避免 marked 强调解析错配导致 Word 加粗范围错误
            let text = preprocessLooseBoldForDocx(mdInput.value);
            if (!text.trim()) return;
            
            // 修复：先把表格块里被换行拆断的行拼回单行，保证 marked 正确识别 table
            text = normalizeMarkdownTables(text);

            // 导出为 Word 可编辑公式（OMML）不依赖 MathJax；只用于预览
            // 检查必需库是否加载成功，并给出详细提示
            const missingLibs = [];
            if (!window.JSZip) {
                missingLibs.push('JSZip（状态: ' + (window.__libs_loading?.jszip || '未加载') + '）');
            }
            if (!window.temml) {
                missingLibs.push('Temml（状态: ' + (window.__libs_loading?.temml || '未加载') + '，window.temml=' + (typeof window.temml) + '）');
            }
            if (!window.mml2omml && !(window.mathml2omml && window.mathml2omml.mml2omml)) {
                missingLibs.push('mathml2omml（状态: ' + (window.__libs_loading?.mathml2omml || '未加载') + '）');
            }
            
            if (missingLibs.length > 0) {
                const msg = '无法导出公式到 Word，缺少以下库：\n' + missingLibs.join('\n') + '\n\n请刷新页面或检查网络连接。按 F12 查看控制台了解详情。';
                alert(msg);
                console.error('缺少库：', missingLibs);
                console.log('当前加载状态：', window.__libs_loading);
                console.log('window.JSZip:', typeof window.JSZip, window.JSZip);
                console.log('window.temml:', typeof window.temml, window.temml);
                console.log('window.mml2omml:', typeof window.mml2omml, window.mml2omml);
                return;
            }
            
            numberingIdCounter = 0;
            const numberingConfigs = [];
            
            const tokens = marked.lexer(text);
            // OMML 注入需要先在 docx 中放占位符，再用 JSZip 替换成真正 OMML
            const mathPlaceholders = []; // { key: string, latex: string, display: boolean }
            const docNodes = await mapTokensToDocx(tokens, 0, numberingConfigs, /* mathCache */ null, { mathMode: 'omml', mathPlaceholders });

            const doc = new docx.Document({
                styles: {
                    default: {
                        document: {
                            run: { font: "Microsoft YaHei", size: 24, color: "000000" },
                            paragraph: { spacing: { line: 360, lineRule: "auto" } }
                        },
                        heading1: {
                            run: { font: "Microsoft YaHei", size: 44, bold: true, color: "000000" },
                            paragraph: { spacing: { before: 480, after: 240 } }
                        },
                        heading2: {
                            run: { font: "Microsoft YaHei", size: 32, bold: true, color: "000000" },
                            paragraph: { spacing: { before: 480, after: 240 } }
                        },
                        heading3: {
                            run: { font: "Microsoft YaHei", size: 28, bold: true, color: "000000" },
                            paragraph: { spacing: { before: 240, after: 120 } }
                        },
                        heading4: {
                            run: { font: "Microsoft YaHei", size: 24, bold: true, color: "000000", italics: false },
                            paragraph: { spacing: { before: 200, after: 100 } }
                        },
                        heading5: {
                            run: { font: "Microsoft YaHei", size: 24, bold: true, color: "000000", italics: false },
                            paragraph: { spacing: { before: 200, after: 100 } }
                        },
                        heading6: {
                            run: { font: "Microsoft YaHei", size: 24, bold: true, color: "000000", italics: false },
                            paragraph: { spacing: { before: 200, after: 100 } }
                        }
                    }
                },
                numbering: {
                    config: numberingConfigs
                },
                sections: [{ children: docNodes }]
            });
            
            try {
                const rawBlob = await docx.Packer.toBlob(doc);
                const injectedBlob = await injectOmmlAndMarkdownIntoDocx(rawBlob, mathPlaceholders, mdInput.value);
                const filename = getFilename();
                saveAs(injectedBlob, filename + ".docx");
                showToast('Word 导出成功（公式可编辑）');
            } catch (err) {
                console.error(err);
                showToast('Word 导出失败（详见控制台）');
            }
        }

        // 为每个有序列表生成唯一的编号配置，并根据层级设置正确的缩进
        function createNumberingConfig(level) {
            const id = `numbering-${numberingIdCounter++}`;
            
            // 关键修复：缩进量 = (层级 + 1) * 每级缩进基准
            // level 0 -> 720 twips
            // level 1 -> 1440 twips
            // level 2 -> 2160 twips
            const leftIndent = (level + 1) * INDENT_PER_LEVEL;
            const hangingIndent = 360; // 悬挂缩进，让编号和文字对齐
            
            return {
                id: id,
                config: {
                    reference: id,
                    levels: [
                        { 
                            level: 0, 
                            format: "decimal", 
                            text: "%1.", 
                            alignment: "start", 
                            style: { 
                                paragraph: { 
                                    indent: { 
                                        left: leftIndent, 
                                        hanging: hangingIndent 
                                    } 
                                } 
                            } 
                        }
                    ]
                }
            };
        }

        async function mapTokensToDocx(tokens, listLevel = 0, numberingConfigs = [], mathCache = null, options = { mathMode: 'omml', mathPlaceholders: [] }) {
            const children = [];

            for (const token of tokens) {
                if (token.type === 'heading') {
                    // token.tokens 为空时也要走 parseInlineTextFromString：否则 "**...**" 在某些中文场景下会原样进入 Word
                    const runs = token.tokens
                        ? await parseInlineText(token, { bold: false, italics: false, color: undefined }, mathCache, options)
                        : await parseInlineTextFromString(token.text || "", { bold: false, italics: false, color: undefined }, mathCache, options);
                    children.push(new docx.Paragraph({
                        children: runs,
                        heading: getHeadingLevel(token.depth)
                    }));
                } 
                else if (token.type === 'paragraph') {
                    const paragraphText = (token.text || '').trim();
                    const isDisplayMathOnly = paragraphText.startsWith('$$') && paragraphText.endsWith('$$') && paragraphText.length >= 4;
                    if (isDisplayMathOnly) {
                        const latex = paragraphText.slice(2, -2).trim();
                        // 块级公式：用占位符段落（后续注入为 OMML）
                        const placeholderKey = createMathPlaceholder(latex, true, options.mathPlaceholders);
                        const runs = [new docx.TextRun({ text: placeholderKey })];
                    children.push(new docx.Paragraph({
                            children: runs,
                            alignment: docx.AlignmentType.CENTER,
                            spacing: { after: 200 }
                        }));
                    } else {
                        children.push(new docx.Paragraph({
                            children: await parseInlineText(token, { bold: false, italics: false, color: undefined }, mathCache, options),
                        spacing: { after: 200 }, 
                        indent: { firstLine: 480 } 
                    }));
                    }
                }
                else if (token.type === 'list') {
                    const isOrdered = token.ordered;
                    
                    // 为每个有序列表创建独立的编号配置
                    let currentNumberingRef = null;
                    if (isOrdered) {
                        const numConfig = createNumberingConfig(listLevel);
                        numberingConfigs.push(numConfig.config);
                        currentNumberingRef = numConfig.id;
                    }
                    
                    for (const item of token.items) {
                        if (!item.tokens) return;

                        let hasRenderedBullet = false;

                        for (const t of item.tokens) {
                            if (t.type === 'list') {
                                // 递归处理嵌套列表，层级 +1
                                const nestedChildren = await mapTokensToDocx([t], listLevel + 1, numberingConfigs, mathCache, options);
                                children.push(...nestedChildren);
                            } 
                            else if (t.type === 'paragraph' || t.type === 'text') {
                                const runs = await parseInlineText(t, { bold: false, italics: false, color: undefined }, mathCache, options);
                                const pOptions = {
                                    children: runs,
                                    spacing: { after: 100 }
                                };

                                if (!hasRenderedBullet) {
                                    if (isOrdered) {
                                        // 有序列表：使用独立的编号引用
                                        pOptions.numbering = { reference: currentNumberingRef, level: 0 };
                                    } else {
                                        // 无序列表：使用 bullet，level 对应当前层级
                                        pOptions.bullet = { level: listLevel };
                                    }
                                    hasRenderedBullet = true;
                                } else {
                                    // 列表项内的后续段落：添加相应缩进
                                    pOptions.indent = { left: (listLevel + 1) * INDENT_PER_LEVEL };
                                }
                                children.push(new docx.Paragraph(pOptions));
                            }
                            else if (t.type === 'blockquote') {
                                const runs = t.tokens
                                    ? await parseInlineText(t, { bold: false, italics: false, color: undefined }, mathCache, options)
                                    : await parseInlineTextFromString(t.text || "", { bold: false, italics: false, color: undefined }, mathCache, options);
                                children.push(new docx.Paragraph({
                                    children: runs,
                                    indent: { left: (listLevel + 1) * INDENT_PER_LEVEL + 480 },
                                    spacing: { after: 200 }
                                }));
                            }
                            else if (t.type === 'table') {
                                const tableNodes = await mapTokensToDocx([t], listLevel, numberingConfigs, mathCache, options);
                                children.push(...tableNodes);
                            }
                        }
                    }
                }
                else if (token.type === 'table') {
                    const tableRows = [];
                    const colCount = Array.isArray(token.header) ? token.header.length : 0;
                    // 表头单元格（支持内联公式）：异步构建
                    const headerCells = [];
                    for (let ci = 0; ci < colCount; ci++) {
                        const h = token.header[ci] ?? "";
                        const paragraphs = await parseCellContent(h, { bold: true, italics: false, color: undefined }, mathCache, options, "center");
                        headerCells.push(new docx.TableCell({
                            children: paragraphs,
                            shading: { fill: "f3f4f6" },
                        }));
                    }
                    tableRows.push(new docx.TableRow({ children: headerCells }));
                    for (const row of token.rows) {
                        // 关键修复：确保每一行的 cell 数量与表头一致
                        // 否则 Word 会把缺失列之后的所有列整体左移，看起来就是“列错乱”
                        const rawCells = Array.isArray(row) ? row.slice() : [];
                        if (colCount > 0) {
                            if (rawCells.length < colCount) {
                                while (rawCells.length < colCount) rawCells.push("");
                            } else if (rawCells.length > colCount) {
                                // 若解析出多余列：合并到最后一列，避免列数溢出
                                const head = rawCells.slice(0, colCount - 1);
                                const tail = rawCells.slice(colCount - 1);
                                rawCells.length = 0;
                                rawCells.push(...head, tail.map(x => (typeof x === "string" ? x : (x && typeof x.text === "string" ? x.text : String(x)))).join(" | "));
                            }
                        }

                        const cells = [];
                        for (let ci = 0; ci < (colCount || rawCells.length); ci++) {
                            const cell = rawCells[ci] ?? "";
                            const paragraphs = await parseCellContent(cell, { bold: false, italics: false, color: undefined }, mathCache, options, "center");
                            cells.push(new docx.TableCell({ children: paragraphs }));
                        }
                        tableRows.push(new docx.TableRow({ children: cells }));
                    }
                    children.push(new docx.Table({
                        rows: tableRows, width: { size: 100, type: "pct" }, spacing: { after: 200 }
                    }));
                }
                else if (token.type === 'blockquote') {
                    const runs = token.tokens
                        ? await parseInlineText(token, { bold: false, italics: false, color: undefined }, mathCache, options)
                        : await parseInlineTextFromString(token.text || "", { bold: false, italics: false, color: undefined }, mathCache, options);
                    children.push(new docx.Paragraph({
                        children: runs, 
                        indent: { left: 480 }, 
                        spacing: { after: 200 }
                    }));
                }
            }
            return children;
        }

        function getHeadingLevel(depth) {
            switch (depth) {
                case 1: return docx.HeadingLevel.HEADING_1;
                case 2: return docx.HeadingLevel.HEADING_2;
                case 3: return docx.HeadingLevel.HEADING_3;
                case 4: return docx.HeadingLevel.HEADING_4;
                case 5: return docx.HeadingLevel.HEADING_5;
                default: return docx.HeadingLevel.HEADING_6;
            }
        }

        // 解析表格单元格内容：支持 <br> / <br/> / <br />，以及被 normalize 后拼接在同一行的内容
        // 每个换行生成一个段落（空行生成空段落）
        async function parseCellContent(cellToken, style, mathCache, options, alignment = "left") {
            // 获取单元格的文本内容（marked 的 table cell 在不同版本里可能是 string 或 { text, tokens }）
            let cellText = "";
            if (cellToken == null) {
                cellText = "";
            } else if (typeof cellToken === "string") {
                cellText = cellToken;
            } else if (typeof cellToken === "object" && typeof cellToken.text === "string") {
                cellText = cellToken.text;
            } else {
                cellText = String(cellToken);
            }
            
            // 统一把 <br> 转成 '\n'，便于按行拆段落
            const normalized = String(cellText || '')
                .replace(/\r\n/g, '\n')
                // 折叠连续 <br>：原 Markdown 常见写法是 <br> + 空行 + <br>，归一化拼接后会变成 <br><br>
                // 这里把多个 <br> 当作“单次换行”，避免生成额外空段落/空行
                .replace(/(<br\s*\/?>\s*){2,}/gi, '<br>')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/\n{2,}/g, '\n');

            // split 保留空段（双 <br> 会产生空行）
            const lines = normalized.split('\n');
            const paragraphs = [];
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // 空行：忽略（避免产生“多一行空行”）
                if (!trimmedLine) continue;
                
                // 创建临时 token 来解析这一行的内联样式（加粗、斜体等）
                let runs = [];
                
                try {
                    // 用 marked.lexer 解析单行以获取内联格式
                    const lineTokens = marked.lexer(trimmedLine);
                    if (lineTokens && lineTokens.length > 0) {
                        const firstToken = lineTokens[0];
                        if (firstToken.tokens && firstToken.tokens.length > 0) {
                            runs = await parseInlineText(firstToken, style, mathCache, options);
                        } else {
                            runs = await parseInlineTextFromString(trimmedLine, style, mathCache, options);
                        }
                    } else {
                        runs = await parseInlineTextFromString(trimmedLine, style, mathCache, options);
                    }
                } catch (e) {
                    console.warn('解析单元格行失败:', e, trimmedLine.substring(0, 50));
                    runs = await parseInlineTextFromString(trimmedLine, style, mathCache, options);
                }
                
                paragraphs.push(new docx.Paragraph({ 
                    children: runs, 
                    alignment: alignment,
                    spacing: { after: 100, before: 0 }
                }));
            }
            
            // 如果没有段落，返回一个空段落
            return paragraphs.length > 0 ? paragraphs : [new docx.Paragraph({ 
                children: [new docx.TextRun({ text: "" })],
                alignment: alignment
            })];
        }

        async function parseInlineText(token, style = { bold: false, italics: false, color: undefined }, mathCache = null, options = { mathMode: 'omml', mathPlaceholders: [] }) {
            if (!token.tokens) {
                return await parseInlineTextFromString(token.text || "", style, mathCache, options);
            }

                const runs = [];
            for (const t of token.tokens) {
                    if (t.type === 'strong') {
                    runs.push(...await parseInlineText(t, { ...style, bold: true }, mathCache, options));
                    } else if (t.type === 'em') {
                    runs.push(...await parseInlineText(t, { ...style, italics: true }, mathCache, options));
                    } else if (t.type === 'link') {
                    // 简化：保留链接文字样式（颜色），不做真正超链接（原代码也是仅变色）
                    runs.push(...await parseInlineText(t, { ...style, color: "0563C1" }, mathCache, options));
                } else if (t.type === 'codespan') {
                    runs.push(new docx.TextRun({ text: t.text || "", font: "Consolas", ...style }));
                } else if (t.type === 'html') {
                    // 跳过 HTML 标签（如 <br>），不添加到 runs 中
                    // 这些标签应该在更高层级处理（如 parseCellContent）
                    continue;
                } else if (t.type === 'br') {
                    // 跳过换行符，应该在段落层级处理
                    continue;
                    } else if (t.type === 'paragraph') {
                        // 关键修复：blockquote 下的段落 token 属于 block-level 容器，不能走"提纯文本"兜底
                        // 否则会把 paragraph.text 与其子 tokens 重复拼接，导致 "注意：注意：" 这类重复，并丢失加粗/斜体等样式
                        runs.push(...await parseInlineText(t, style, mathCache, options));
                    } else if (t.type === 'text') {
                        if (t.tokens && t.tokens.length > 0) {
                        runs.push(...await parseInlineText(t, style, mathCache, options));
                        } else {
                        runs.push(...await parseInlineTextFromString(t.text || "", style, mathCache, options));
                        }
                    } else {
                    // 其他类型：尽量提取文本
                    const text = (t.tokens && t.tokens.length > 0) ? extractTextFromTokens(t.tokens) : (t.text || "");
                    runs.push(...await parseInlineTextFromString(text, style, mathCache, options));
                }
            }
            return runs;
        }

        function createMathPlaceholder(latex, displayMode, mathPlaceholders) {
            const id = mathPlaceholders.length;
            const key = `__MATH_${id}__`;
            mathPlaceholders.push({ key, latex: String(latex || ""), display: !!displayMode });
            return key;
        }

        async function parseInlineTextFromString(text, style, mathCache, options) {
            const segments = splitTextAndMath(text || "");
            const runs = [];
            
            // 调试：如果文本包含多个公式，记录分段结果
            if (text && text.includes('$') && segments.length > 3) {
                console.log('复杂公式段落分段:', text.substring(0, 100), '...', '分段数:', segments.length);
            }
            
            for (const seg of segments) {
                if (seg.type === 'text') {
                    if (seg.value) runs.push(...buildRunsFromLooseBold(seg.value, style));
                } else if (seg.type === 'math') {
                    // OMML 模式：写占位符，稍后注入为 Word 可编辑公式
                    if (options && options.mathMode === 'omml') {
                        const key = createMathPlaceholder(seg.value, seg.display, options.mathPlaceholders || []);
                        runs.push(new docx.TextRun({ text: key, ...style }));
                        continue;
                    }

                    // 兼容：如果未来需要回退到图片/上下标模式，可扩展
                    const fallback = seg.display ? `$$${seg.value}$$` : `$${seg.value}$`;
                    runs.push(new docx.TextRun({ text: fallback, ...style }));
                }
            }
            return runs;
        }

        // 宽松的 **...** 加粗解析（用于中文场景：例如 “做**“时间-温度”**。” 在 CommonMark 规则下可能不被 marked 识别为 strong）
        // 只做最小兜底：不处理嵌套，不跨段落；找不到成对 ** 则保留原样。
        function buildRunsFromLooseBold(text, style) {
            const s = String(text || "");
            const hasDocxMarkers = s.includes(DOCX_BOLD_OPEN) || s.includes(DOCX_BOLD_CLOSE);
            const hasAsterisks = s.includes('**');
            if (!hasDocxMarkers && !hasAsterisks) return s ? [new docx.TextRun({ text: s, ...style })] : [];

            const stripMarkers = (v) => String(v || '').replace(new RegExp(DOCX_BOLD_OPEN, 'g'), '').replace(new RegExp(DOCX_BOLD_CLOSE, 'g'), '');

            // 优先处理显式开/关标记（导出侧预处理生成，最可靠）
            if (hasDocxMarkers) {
                const out = [];
                let i = 0;
                while (i < s.length) {
                    const open = s.indexOf(DOCX_BOLD_OPEN, i);
                    if (open === -1) {
                        const tail = stripMarkers(s.slice(i));
                        if (tail) out.push(new docx.TextRun({ text: tail, ...style }));
                        break;
                    }
                    const before = stripMarkers(s.slice(i, open));
                    if (before) out.push(new docx.TextRun({ text: before, ...style }));

                    const close = s.indexOf(DOCX_BOLD_CLOSE, open + 1);
                    if (close === -1) {
                        // 未闭合：把剩余当普通文本（移除标记）
                        const rest = stripMarkers(s.slice(open + 1));
                        if (rest) out.push(new docx.TextRun({ text: rest, ...style }));
                        break;
                    }
                    const boldText = stripMarkers(s.slice(open + 1, close));
                    if (boldText) out.push(new docx.TextRun({ text: boldText, ...style, bold: true }));
                    i = close + 1;
                }
                return out;
            }

            const out = [];
            let i = 0;
            while (i < s.length) {
                const open = s.indexOf('**', i);
                if (open === -1) {
                    const tail = s.slice(i);
                    if (tail) out.push(new docx.TextRun({ text: tail, ...style }));
                    break;
                }

                // 普通文本
                const before = s.slice(i, open);
                if (before) out.push(new docx.TextRun({ text: before, ...style }));

                const close = s.indexOf('**', open + 2);
                if (close === -1) {
                    // 没有闭合：把剩余当普通文本（保留 **）
                    const rest = s.slice(open);
                    if (rest) out.push(new docx.TextRun({ text: rest, ...style }));
                    break;
                }

                const boldText = s.slice(open + 2, close);
                if (boldText) {
                    out.push(new docx.TextRun({ text: boldText, ...style, bold: true }));
                }
                i = close + 2;
            }

            return out;
        }

        function escapeXml(text) {
            return String(text || "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/\"/g, "&quot;")
                .replace(/'/g, "&apos;");
        }

        function escapeRegExp(str) {
            return String(str || "").replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function utf8ToBase64(str) {
            const bytes = new TextEncoder().encode(String(str || ""));
            let bin = "";
            for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
            return btoa(bin);
        }

        function base64ToUtf8(b64) {
            const bin = atob(String(b64 || ""));
            const bytes = new Uint8Array(bin.length);
            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
            return new TextDecoder('utf-8').decode(bytes);
        }

        function temmlToMathML(latex, displayMode) {
            const t = window.temml || window.Temml;
            if (!t) {
                const errMsg = `Temml 库不可用。window.temml=${typeof window.temml}, window.Temml=${typeof window.Temml}, 加载状态=${window.__libs_loading?.temml}`;
                console.error(errMsg);
                console.log('完整 window.temml 对象：', window.temml);
                throw new Error(errMsg);
            }
            if (!t.renderToMathMLTree && !t.renderToString) {
                const errMsg = `Temml 已加载但缺少必需方法。可用方法：${Object.keys(t).join(', ')}`;
                console.error(errMsg);
                throw new Error(errMsg);
            }
            
            // 优先使用 renderToMathMLTree，如果不存在则尝试 renderToString
            let mathmlString;
            if (t.renderToMathMLTree) {
                const tree = t.renderToMathMLTree(String(latex || ""), { displayMode: !!displayMode, throwOnError: false });
                const mathNode = (tree && tree.nodeName && tree.nodeName.toLowerCase() === 'math')
                    ? tree
                    : (tree && tree.querySelector ? tree.querySelector('math') : null);
                const node = mathNode || tree;
                mathmlString = new XMLSerializer().serializeToString(node);
            } else if (t.renderToString) {
                mathmlString = t.renderToString(String(latex || ""), { displayMode: !!displayMode, throwOnError: false });
            }
            return mathmlString;
        }

        function mathmlToOmml(mathmlString) {
            if (typeof window.mml2omml === 'function') {
                return window.mml2omml(mathmlString);
            }
            if (window.mathml2omml && typeof window.mathml2omml.mml2omml === 'function') {
                return window.mathml2omml.mml2omml(mathmlString);
            }
            // index.min.js 通常会导出一个全局 mml2omml；兜底：尝试命名空间
            if (typeof window.mml2omml === 'object' && typeof window.mml2omml.mml2omml === 'function') {
                return window.mml2omml.mml2omml(mathmlString);
            }
            throw new Error("mathml2omml 不可用");
        }

        function ensureMathNamespace(documentXml) {
            // 确保 document.xml 根节点有 m 命名空间
            if (documentXml.includes('xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"')) {
                return documentXml;
            }
            return documentXml.replace(
                /<w:document\b([^>]*)>/,
                '<w:document$1 xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math">'
            );
        }

        function buildHiddenMarkdownParagraph(markdown) {
            const begin = "__MARK2WORD_MD_B64_BEGIN__";
            const end = "__MARK2WORD_MD_B64_END__";
            const b64 = utf8ToBase64(markdown || "");
            // 分块避免单个 w:t 过长
            const chunkSize = 1500;
            const chunks = [];
            for (let i = 0; i < b64.length; i += chunkSize) chunks.push(b64.slice(i, i + chunkSize));

            let runsXml = '';
            runsXml += `<w:r><w:rPr><w:vanish/></w:rPr><w:t xml:space="preserve">${begin}</w:t></w:r>`;
            for (const c of chunks) {
                runsXml += `<w:r><w:rPr><w:vanish/></w:rPr><w:t xml:space="preserve">${escapeXml(c)}</w:t></w:r>`;
            }
            runsXml += `<w:r><w:rPr><w:vanish/></w:rPr><w:t xml:space="preserve">${end}</w:t></w:r>`;

            return `<w:p>${runsXml}</w:p>`;
        }

        async function injectOmmlAndMarkdownIntoDocx(rawBlob, mathPlaceholders, markdown) {
            const zip = await JSZip.loadAsync(rawBlob);
            const docPath = 'word/document.xml';
            const docXml = await zip.file(docPath).async('string');

            // 关键修复：不要用正则整段替换 <w:r>，否则如果同一个 run 内包含多个 <w:t>，会把公式前后文本一起删掉。
            // 改为解析 XML，精确在 <w:t> 内替换占位符。
            let xml = ensureMathNamespace(docXml);
            xml = injectOmmlIntoDocumentXml(xml, mathPlaceholders || []);

            // 2) 附加隐藏 Markdown（用于可逆导入）
            const hidden = buildHiddenMarkdownParagraph(markdown || "");
            xml = xml.replace(/<\/w:body>/, `${hidden}</w:body>`);

            zip.file(docPath, xml);
            return await zip.generateAsync({ type: 'blob' });
        }

        function injectOmmlIntoDocumentXml(documentXml, mathPlaceholders) {
            if (!mathPlaceholders || mathPlaceholders.length === 0) return documentXml;

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(documentXml, 'application/xml');
            const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
            if (parseError) {
                console.error('document.xml 解析失败：', parseError.textContent);
                return documentXml; // 兜底：不注入，避免破坏 docx
            }

            // 预先生成 key -> { display, ommlXmlString }
            const ommlMap = new Map();
            for (const item of mathPlaceholders) {
                const mathml = temmlToMathML(item.latex, item.display);
                let omml = mathmlToOmml(mathml);

                const hasOMathPara = /<m:oMathPara[\s>]/.test(omml);
                const hasOMath = /<m:oMath[\s>]/.test(omml);

                if (item.display) {
                    if (!hasOMathPara) {
                        if (!hasOMath) omml = `<m:oMath>${omml}</m:oMath>`;
                        omml = `<m:oMathPara>${omml}</m:oMathPara>`;
                    }
                } else {
                    if (!hasOMath) omml = `<m:oMath>${omml}</m:oMath>`;
                }

                ommlMap.set(item.key, { display: !!item.display, omml });
            }

            // 遍历所有 w:t，找包含占位符的文本节点进行替换
            const textNodes = Array.from(xmlDoc.getElementsByTagName('w:t'));
            const placeholderRe = /__MATH_\d+__/g;

            for (const tNode of textNodes) {
                const txt = tNode.textContent || '';
                if (!txt.includes('__MATH_')) continue;

                const matches = txt.match(placeholderRe);
                if (!matches || matches.length === 0) continue;

                // 同一个 w:t 里可能出现多个占位符（理论上不多），逐个处理
                let currentText = txt;
                let replacedAny = false;

                // 获取 run / paragraph
                const runNode = findAncestor(tNode, 'w:r');
                const paraNode = findAncestor(tNode, 'w:p');
                if (!runNode || !paraNode) continue;

                // 如果其中包含 display 公式，占位符通常是整段独立段落；我们直接替换整个段落内容为 oMathPara
                // （避免 run 内混排导致结构复杂）
                const hasDisplay = matches.some((k) => ommlMap.get(k)?.display);
                if (hasDisplay) {
                    // 找到第一个 display key
                    const key = matches.find((k) => ommlMap.get(k)?.display);
                    const entry = key ? ommlMap.get(key) : null;
                    if (!entry) continue;

                    // 清空段落内除 w:pPr 外的节点
                    const children = Array.from(paraNode.childNodes);
                    for (const ch of children) {
                        if (ch.nodeType === 1 && ch.nodeName === 'w:pPr') continue;
                        paraNode.removeChild(ch);
                    }

                    // 插入 m:oMathPara 片段
                    const ommlNodes = parseOmmlFragment(xmlDoc, entry.omml);
                    for (const n of ommlNodes) paraNode.appendChild(n);

                    replacedAny = true;
                } else {
                    // inline：在 run 内把 w:t 拆成 [文本][oMath][文本]，不删掉同 run 的其他 w:t
                    // 构造一个 DocumentFragment 替换当前 w:t 节点
                    const frag = xmlDoc.createDocumentFragment();
                    while (true) {
                        const m = placeholderRe.exec(currentText);
                        if (!m) break;
                        const key = m[0];
                        const entry = ommlMap.get(key);
                        if (!entry) continue;

                        const idx = currentText.indexOf(key);
                        const before = currentText.slice(0, idx);
                        const after = currentText.slice(idx + key.length);

                        if (before) frag.appendChild(createWT(xmlDoc, before));
                        const ommlNodes = parseOmmlFragment(xmlDoc, entry.omml);
                        for (const n of ommlNodes) frag.appendChild(n);

                        currentText = after;
                        replacedAny = true;
                        // reset regex state for new string
                        placeholderRe.lastIndex = 0;
                    }
                    if (currentText) frag.appendChild(createWT(xmlDoc, currentText));

                    // 用 frag 替换当前 w:t（保持同一个 w:r 不被整体替换）
                    if (replacedAny) {
                        runNode.insertBefore(frag, tNode);
                        runNode.removeChild(tNode);
                    }
                }

                // 这个 w:t 已处理，继续
                if (replacedAny) continue;
            }

            return new XMLSerializer().serializeToString(xmlDoc);
        }

        function findAncestor(node, tagName) {
            let cur = node;
            while (cur && cur.parentNode) {
                if (cur.nodeType === 1 && cur.nodeName === tagName) return cur;
                cur = cur.parentNode;
            }
            return null;
        }

        function createWT(xmlDoc, text) {
            const wT = xmlDoc.createElement('w:t');
            // 保留空格
            wT.setAttribute('xml:space', 'preserve');
            wT.textContent = text;
            return wT;
        }

        function parseOmmlFragment(xmlDoc, ommlString) {
            // 解析 OMML 片段，返回可直接插入的节点数组（导入到 xmlDoc）
            const wrapped = `<root xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math">${ommlString}</root>`;
            const parsed = new DOMParser().parseFromString(wrapped, 'application/xml');
            const err = parsed.getElementsByTagName('parsererror')[0];
            if (err) {
                console.error('OMML 片段解析失败：', err.textContent, ommlString);
                return [xmlDoc.createTextNode(ommlString)];
            }
            const root = parsed.documentElement;
            const nodes = [];
            for (const ch of Array.from(root.childNodes)) {
                nodes.push(xmlDoc.importNode(ch, true));
            }
            return nodes;
        }

        async function importDocxFile(file) {
            const buf = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(buf);
            const docPath = 'word/document.xml';
            const docXml = await zip.file(docPath).async('string');

            // 优先：从隐藏段落恢复原始 Markdown（100% 可逆，适用于本工具导出的 docx）
            const begin = "__MARK2WORD_MD_B64_BEGIN__";
            const end = "__MARK2WORD_MD_B64_END__";
            const start = docXml.indexOf(begin);
            const stop = docXml.indexOf(end);
            if (start !== -1 && stop !== -1 && stop > start) {
                // 这里 docXml 是原始 XML 字符串；我们写入的是纯 base64（不含 <>&），直接抽取即可
                const b64 = docXml.slice(start + begin.length, stop).replace(/\s+/g, '');
                const md = base64ToUtf8(b64);
                mdInput.value = md;
                updateFilenameFromContent();
                convertMdToPreview();
                return;
            }

            // 降级：非本工具导出 docx —— 仅尽力提取纯文本（公式暂无法可靠还原）
            const text = extractPlainTextFromDocxXml(docXml);
            mdInput.value = text;
            updateFilenameFromContent();
            convertMdToPreview();
            showToast('提示：此 docx 非本工具导出，仅恢复了纯文本');
        }

        function extractPlainTextFromDocxXml(docXml) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, 'application/xml');
                const paragraphs = Array.from(xmlDoc.getElementsByTagName('w:p'));
                const lines = paragraphs.map(p => {
                    const texts = Array.from(p.getElementsByTagName('w:t')).map(t => t.textContent || '');
                    return texts.join('');
                });
                return lines.join('\n\n').trim();
            } catch {
                // 最后兜底：粗暴去标签
                return String(docXml || '').replace(/<[^>]+>/g, '').trim();
            }
        }

        function splitTextAndMath(input) {
            // 解析 $...$、$$...$$，以及 \begin{equation}...\end{equation}，支持 \$ 转义
            const s = String(input || "");
            const out = [];
            let i = 0;
            let textBuffer = "";  // 累积普通文本

            const flushText = () => {
                if (textBuffer) {
                    out.push({ type: 'text', value: textBuffer });
                    textBuffer = "";
                }
            };

            while (i < s.length) {
                const ch = s[i];
                
                // 处理转义的 \$
                if (ch === '\\' && s[i + 1] === '$') {
                    textBuffer += '$';
                    i += 2;
                    continue;
                }

                // 兼容 LaTeX equation 环境：\begin{equation} ... \end{equation}
                // 注：Temml/OMML 通常不需要外层 environment，提取内部公式即可
                if (ch === '\\' && s.startsWith('\\begin{equation}', i)) {
                    const beginTag = '\\begin{equation}';
                    const endTag = '\\end{equation}';
                    const start = i + beginTag.length;
                    const end = s.indexOf(endTag, start);
                    if (end !== -1) {
                        flushText();
                        const latex = s.slice(start, end).trim();
                        out.push({ type: 'math', value: latex, display: true });
                        i = end + endTag.length;
                        continue;
                    }
                    // 找不到 endTag：按普通文本处理
                }

                // 尝试匹配公式 $ 或 $$
                if (ch === '$') {
                    const isDouble = s[i + 1] === '$';
                    const delim = isDouble ? '$$' : '$';
                    const delimLen = delim.length;
                    const start = i + delimLen;
                    let j = start;
                    
                    // 查找结束符
                    while (j < s.length) {
                        if (s[j] === '\\' && s[j + 1] === '$') {
                            j += 2;
                            continue;
                        }
                        if (isDouble) {
                            if (s[j] === '$' && s[j + 1] === '$') break;
                        } else {
                            if (s[j] === '$') break;
                        }
                        j++;
                    }

                    // 检查是否找到了完整的公式
                    const found = isDouble 
                        ? (j <= s.length - 2 && s[j] === '$' && s[j + 1] === '$') 
                        : (j < s.length && s[j] === '$');
                    
                    if (found) {
                        // 找到完整公式：先输出累积的文本，再输出公式
                        flushText();
                        const latex = s.slice(start, j).trim();
                        out.push({ type: 'math', value: latex, display: isDouble });
                        i = j + delimLen;
                        continue;
                    } else {
                        // 没找到匹配的结束符：把开头的 $ 当作普通字符
                        textBuffer += '$';
                        i += 1;
                        continue;
                    }
                }

                // 普通字符：加入 buffer
                textBuffer += ch;
                i++;
            }

            flushText();
            return out.length ? out : [{ type: 'text', value: s }];
        }

        async function ensureMathJaxReady() {
            if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                await window.MathJax.startup.promise;
                return;
            }
            // 兜底：轮询等待
            await new Promise((resolve, reject) => {
                const start = Date.now();
                const timer = setInterval(() => {
                    if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                        clearInterval(timer);
                        window.MathJax.startup.promise.then(resolve).catch(reject);
                        return;
                    }
                    if (Date.now() - start > 15000) {
                        clearInterval(timer);
                        reject(new Error("MathJax 加载超时"));
                    }
                }, 100);
            });
        }

        async function createMathImageRun(latex, displayMode, mathCache) {
            const key = `${displayMode ? 1 : 0}:${latex}`;
            const cached = mathCache.get(key);
            if (cached) {
                return new docx.ImageRun({
                    data: cached.data,
                    transformation: { width: cached.width, height: cached.height }
                });
            }

            const svg = latexToSvgElement(latex, displayMode);
            const viewBox = svg.getAttribute('viewBox') || '0 0 100 20';
            const vb = viewBox.split(/\s+/).map(Number);
            const vbW = (vb.length >= 4 && isFinite(vb[2])) ? vb[2] : 100;
            const vbH = (vb.length >= 4 && isFinite(vb[3])) ? vb[3] : 20;

            // 经验尺寸：行内 ~ 18px 高，块级 ~ 34px 高
            const targetH = displayMode ? 34 : 18;
            const targetW = Math.max(1, Math.round(targetH * (vbW / vbH)));

            svg.setAttribute('width', `${targetW}px`);
            svg.setAttribute('height', `${targetH}px`);

            const data = await svgToPngBytes(svg, targetW, targetH);

            const record = { data, width: targetW, height: targetH };
            mathCache.set(key, record);

            return new docx.ImageRun({
                data: record.data,
                transformation: { width: record.width, height: record.height }
            });
        }

        function latexToSvgElement(latex, displayMode) {
            // MathJax.tex2svg 返回一个包含 svg 的节点
            const node = window.MathJax.tex2svg(latex, { display: !!displayMode });
            const svg = node.querySelector('svg');
            if (!svg) throw new Error("MathJax 未生成 SVG");
            return svg;
        }

        async function blobToUint8Array(blob) {
            const buf = await blob.arrayBuffer();
            return new Uint8Array(buf);
        }

        async function svgToPngBytes(svgElement, width, height) {
            const svgClone = svgElement.cloneNode(true);
            // 移除可能影响绘制的样式
            svgClone.removeAttribute('style');
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            svgClone.setAttribute('width', `${width}`);
            svgClone.setAttribute('height', `${height}`);

            const svgText = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            try {
                const img = await new Promise((resolve, reject) => {
                    const image = new Image();
                    image.onload = () => resolve(image);
                    image.onerror = reject;
                    image.src = url;
                });

                const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
                const canvas = document.createElement('canvas');
                canvas.width = width * dpr;
                canvas.height = height * dpr;

                const ctx = canvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0, width, height);

                const pngBlob = await new Promise((resolve, reject) => {
                    canvas.toBlob((b) => (b ? resolve(b) : reject(new Error("canvas.toBlob 失败"))), 'image/png');
                });
                return await blobToUint8Array(pngBlob);
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function tryBuildSimpleScriptRunsFromLatex(latex, style) {
            // 仅支持非常常见的简单形式：x_{y} / x^{y} / x_{y}^{z}，其中 x 为单个字符，y/z 不含嵌套花括号
            const s = String(latex || '').trim();
            const m = s.match(/^([A-Za-z0-9])(?:_\{([^{}]+)\})?(?:\^\{([^{}]+)\})?$/);
            if (!m) return null;
            const base = m[1];
            const sub = m[2];
            const sup = m[3];

            const runs = [new docx.TextRun({ text: base, ...style })];
            if (sub) runs.push(new docx.TextRun({ text: sub, subScript: true, ...style }));
            if (sup) runs.push(new docx.TextRun({ text: sup, superScript: true, ...style }));
                return runs;
            }

        // 预览区：把文本里的 $...$ / $$...$$ 包成占位节点（保留原始 TeX，便于 turndown 还原）
        function wrapMathInDom(root) {
            if (!root) return;
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (!node || !node.nodeValue || node.nodeValue.indexOf('$') === -1) return NodeFilter.FILTER_REJECT;
                    const p = node.parentNode;
                    if (!p) return NodeFilter.FILTER_REJECT;
                    const tag = (p.nodeName || '').toUpperCase();
                    if (tag === 'CODE' || tag === 'PRE' || tag === 'SCRIPT' || tag === 'STYLE') return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });

            const textNodes = [];
            let cur;
            while ((cur = walker.nextNode())) textNodes.push(cur);

            for (const node of textNodes) {
                const segments = splitTextAndMath(node.nodeValue || "");
                if (!segments.some(s => s.type === 'math')) continue;

                const frag = document.createDocumentFragment();
                for (const seg of segments) {
                    if (seg.type === 'text') {
                        frag.appendChild(document.createTextNode(seg.value || ""));
                    } else {
                        const el = document.createElement(seg.display ? 'div' : 'span');
                        el.className = seg.display ? 'tex-block' : 'tex-inline';
                        el.setAttribute('data-tex', seg.value || "");
                        // 初始显示原文，确保未渲染/渲染失败时可见
                        el.textContent = seg.display ? `$$${seg.value}$$` : `$${seg.value}$`;
                        frag.appendChild(el);
                    }
                }
                node.parentNode.replaceChild(frag, node);
            }
        }

        // 预览区：把文本里的 **...**（宽松匹配）转换成 <strong>...</strong>
        // 用于中文标点/引号紧贴时 marked 可能不识别 strong 的场景；跳过 code/pre/script/style 等区域
        function wrapLooseBoldInDom(root) {
            if (!root) return;
            const EXCLUDED_TAGS = new Set(['CODE', 'PRE', 'SCRIPT', 'STYLE']);

            const countOccurrences = (haystack, needle) => {
                const s = String(haystack || '');
                const n = String(needle || '');
                if (!n) return 0;
                let count = 0;
                let idx = 0;
                while (true) {
                    const at = s.indexOf(n, idx);
                    if (at === -1) break;
                    count++;
                    idx = at + n.length;
                }
                return count;
            };

            // 仅在“同一父元素的直接子节点”层面做跨节点配对，避免破坏更深层结构（如链接/代码等）
            function fixLooseBoldInDirectChildren(container) {
                if (!container || !container.childNodes || container.childNodes.length === 0) return;
                const tag = (container.nodeName || '').toUpperCase();
                if (EXCLUDED_TAGS.has(tag) || tag === 'STRONG') return;

                const children = Array.from(container.childNodes);
                // 只统计“直接 text 节点”中的 ** 数量；嵌套元素里的 ** 由递归到子元素时处理
                let markerCount = 0;
                for (const ch of children) {
                    if (ch.nodeType === 3) markerCount += countOccurrences(ch.nodeValue, '**');
                }
                if (markerCount < 2 || markerCount % 2 === 1) return;

                let bold = false;
                let currentStrong = null;
                const frag = document.createDocumentFragment();

                const ensureStrong = () => {
                    if (!currentStrong) {
                        currentStrong = document.createElement('strong');
                        frag.appendChild(currentStrong);
                    }
                };
                const appendNode = (node) => {
                    if (!node) return;
                    if (bold) {
                        ensureStrong();
                        currentStrong.appendChild(node);
                    } else {
                        // 关闭当前 strong（避免后续继续复用）
                        currentStrong = null;
                        frag.appendChild(node);
                    }
                };

                for (const ch of children) {
                    if (ch.nodeType === 3) {
                        const text = ch.nodeValue || '';
                        if (!text.includes('**')) {
                            appendNode(document.createTextNode(text));
                            continue;
                        }
                        let i = 0;
                        while (i < text.length) {
                            const open = text.indexOf('**', i);
                            if (open === -1) {
                                const tail = text.slice(i);
                                if (tail) appendNode(document.createTextNode(tail));
                                break;
                            }
                            const before = text.slice(i, open);
                            if (before) appendNode(document.createTextNode(before));
                            // toggle
                            bold = !bold;
                            if (!bold) currentStrong = null;
                            i = open + 2;
                        }
                        continue;
                    }

                    // 元素节点：保持原节点，但根据当前 bold 状态决定是否包裹进 strong
                    // 注意：不处理 ch 内部（递归会在外层遍历中处理其子元素）
                    const chTag = (ch.nodeName || '').toUpperCase();
                    const moved = ch; // 直接移动节点，避免 clone 丢事件（预览区一般也无事件）
                    if (EXCLUDED_TAGS.has(chTag) || chTag === 'STRONG') {
                        // 排除节点：不改变其内部结构；但如果当前处于 bold 状态，仍允许被包裹（多数场景无影响）
                        appendNode(moved);
                    } else {
                        appendNode(moved);
                    }
                }

                // 替换 DOM
                container.textContent = '';
                container.appendChild(frag);
            }

            // 遍历所有元素（含 root 本身），逐层处理，确保 ** 分散在多个 text node 时也能正确配对
            const elements = [root, ...Array.from(root.querySelectorAll('*'))];
            for (const el of elements) fixLooseBoldInDirectChildren(el);
        }

        function splitTextAndLooseBold(text) {
            const s = String(text || "");
            const out = [];
            let i = 0;
            while (i < s.length) {
                const open = s.indexOf('**', i);
                if (open === -1) {
                    out.push({ type: 'text', value: s.slice(i) });
                    break;
                }
                if (open > i) out.push({ type: 'text', value: s.slice(i, open) });
                const close = s.indexOf('**', open + 2);
                if (close === -1) {
                    // 没有闭合：保留原样（包含 **）
                    out.push({ type: 'text', value: s.slice(open) });
                    break;
                }
                out.push({ type: 'bold', value: s.slice(open + 2, close) });
                i = close + 2;
            }
            return out;
        }

        async function renderMathInPreview(root) {
            try {
                await ensureMathJaxReady();
            } catch {
                return;
            }
            if (!root) return;
            const nodes = root.querySelectorAll('.tex-inline[data-tex], .tex-block[data-tex]');
            for (const n of nodes) {
                const latex = n.getAttribute('data-tex') || '';
                const displayMode = n.classList.contains('tex-block');
                try {
                    const svg = latexToSvgElement(latex, displayMode);
                    // 预览：直接放 svg（更清晰）
                    n.innerHTML = '';
                    n.appendChild(svg);
                } catch {
                    // ignore
                }
            }
        }

        // 辅助函数：从 tokens 数组中递归提取纯文本
        function extractTextFromTokens(tokens) {
            if (!tokens || tokens.length === 0) return '';
            let text = '';
            tokens.forEach(t => {
                // 避免重复：像 paragraph/strong 这类 token 往往同时有 text 和 tokens
                // 直接拼 text 再递归 tokens 会造成 “X X” 重复
                if (t.tokens && t.tokens.length > 0) {
                    text += extractTextFromTokens(t.tokens);
                } else if (t.text) {
                    text += t.text;
                }
            });
            return text;
        }
    </script>
</body>
</html>